/*
    Warning - this file was autogenerated by genparse
    DO NOT EDIT - any changes will be lost
*/

#include "at_command.h"

#include <ctype.h>
#include <panic.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <util.h> /* hash and compare */

#if (defined TEST_HARNESS || defined DISPLAY_AT_CMDS)
#include <stdio.h>
#endif

typedef const uint8 *ptr;

static __inline__ char my_toupper(char c)
{ return 'a' <= c && c <= 'z' ? c +'A'-'a' : c; }

static ptr skip1(ptr s, ptr e)
{
  if(s)
    while(s != e && (*s == ' ' || *s == '\t'))
      ++s;
  return s;
}

static ptr skipOnce1(ptr s, ptr e)
{
  if(s)
  {
    if(s != e && (*s == ',' || *s == ';'))
      ++s;
  }
  return s;
}

static ptr match1(ptr s, ptr e)
{ return s && s != e && (*s == '\r' || *s == '\n') ? s+1 : 0; }

static ptr findEndOfPacket(ptr s, ptr e)
{
  /*
     Returns
     0   if the buffer holds an incomplete packet
     s+1 if the buffer holds an invalid packet
     end of the first packet otherwise
  */
  if(s == e) return 0;

  if(*s == '\r')
  {
    /* expecting <cr> <lf> ... <cr> <lf> */
    if(e-s >= 4)
    {
      if(s[1] == '\n' && s[2] != '\r')
      {
        ptr p = s+2;
        if(*p != '\r')
        {
#ifndef TEST_HARNESS
        p = (const uint8*)UtilFind(0xFFFF, '\r', (const uint16*)p, 0, 1, (uint16)(e-p));
#endif
#ifdef TEST_HARNESS
		   while(p != e && *p != '\r') p++;
#endif
        return p == 0 || p + 1 == e ? 0 /* no terminator yet */
             : p[1] == '\n' ? p+2 /* valid */
             : s+1 ; /* invalid terminator */
         }
         else
             return s+1;
      }
      else
      {
        return s+1;
      }
    }
    else
    {
      /* Can't tell yet */
      return 0;
    }
  }
  else
  {
    /* expecting ... <cr> */
    ptr p = s;
    while(p != e && (*p == ' ' || *p == '\n' || *p == '\0' || *p == '\t')) ++p;
    if(p != e && *p == '\r') return s+1;
    while(p != e && *p != '\r') ++p;
    return p == e ? 0 : p+1;
  }
}

#ifndef TEST_HARNESS
#ifdef __XAP__
uint16 parseSource(Source rfcDataIn, Task task)
{
  ptr s = SourceMap(rfcDataIn);
  ptr e = s + SourceSize(rfcDataIn);
  ptr p = parseData(s, e, task);
  if(p != s)
  {
    SourceDrop(rfcDataIn, (uint16) (p - s));
    return 1;
  }
  else
  {
    return 0;
  }
}
#endif
#endif

typedef struct {
  char c;
  int to;
} Arc;

static const Arc arcs[] = {
  { '\t', 0 },
  { '\n', 1 },
  { '\r', 1 },
  { ' ', 0 },
  { '\n', 2 },
  { '\r', 2 },
  { '\t', 2 },
  { ' ', 2 },
  { 'A', 3 },
  { 'T', 4 },
  { '\t', 4 },
  { ' ', 4 },
  { '+', 5 },
  { '\t', 5 },
  { ' ', 5 },
  { 'C', 6 },
  { 'O', 7 },
  { 'N', 8 },
  { 'N', 9 },
  { 'E', 10 },
  { 'C', 11 },
  { 'T', 12 },
  { '\t', 12 },
  { ' ', 12 },
  { ':', -1 },
  { '=', -1 },
};

static const Arc *const states[14] = {
  &arcs[0],
  &arcs[4],
  &arcs[6],
  &arcs[9],
  &arcs[10],
  &arcs[13],
  &arcs[16],
  &arcs[17],
  &arcs[18],
  &arcs[19],
  &arcs[20],
  &arcs[21],
  &arcs[22],
  &arcs[26],
};

static uint16 matchLiteral(ptr s, ptr e, Task task)
{ s=s; e=e; task=task; return 0; }

ptr parseData(ptr s, ptr e, Task task)
{
  ptr p;

#ifdef DISPLAY_AT_CMDS
  {
  	ptr c = s;
    printf("\nreceived: ");
  	while (c != e)
  	{
		if (*c == '\r')			printf("\\r");
		else if (*c == '\n') 	printf("\\n");
		else 					putchar(*c);

		c++;
  	}
  }
#endif

#ifdef TEST_HARNESS
  task = task;
#endif
  for(; (p = findEndOfPacket(s, e)) != 0; s = p)
  {
    if(p == s+1)
    {
      /* Silently discard one character; no packets are that short */
      continue;
    }
    else if(matchLiteral(s, p, task))
    {
      continue;
    }
    else
    {
      union {
        struct connect connect;
      } u, *uu = &u;
      int state = 0;
      ptr t = s;
      while(t != e && state >= 0)
      {
        char m = my_toupper((char) *t);
        const Arc *a = states[state];
        const Arc *const last_a = states[state+1];
#ifndef TEST_HARNESS
        a = (const Arc *) (void *) UtilFind(0xFFFF, (uint16) m, (const uint16 *) (void *) &a[0].c, 0, sizeof(Arc), (uint16) (last_a - a));
#endif
#ifdef TEST_HARNESS
        while(a != last_a && a->c != m) a++;
#endif
        /*lint -e{801} suppress goto is deprecated */
        if(!a) goto unrecognised;
        state = a->to;
        ++t;
      }
      switch(-state)
      {
        case 1:
          if(match1(match1(skip1(UtilGetNumber(skip1(skipOnce1(UtilGetNumber(skip1(skipOnce1(UtilGetNumber(skip1(t, e), e, &uu->connect.baudrate), e), e), e, &uu->connect.stop), e), e), e, &uu->connect.parity), e), e), e))
          {
#ifndef TEST_HARNESS
            connect(task, &uu->connect);
#endif
#ifdef TEST_HARNESS
            printf("Called connect");
            printf(" baudrate=%d", uu->connect.baudrate);
            printf(" stop=%d", uu->connect.stop);
            printf(" parity=%d", uu->connect.parity);
            putchar('\n');
#endif
            continue;
          }
          break;
        default:
          break;
      }
      /*
        The message does not contain a recognised AT command or response.
        Pass the data on to the application to have a go at 
      */
unrecognised:
#ifndef TEST_HARNESS
      handleUnrecognised(s, (uint16) (p-s), task);
#endif
#ifdef TEST_HARNESS
      printf("Called handleUnrecognised\n");
#endif
    }
  }

  return s;
}

/*
connect
   Skip " \t"
   Match "\r\n"
   Match "\r\n"
   Skip " \t"
   MatchChar A
   MatchChar T
   Skip " \t"
   MatchChar +
   Skip " \t"
   MatchChar C
   MatchChar O
   MatchChar N
   MatchChar N
   MatchChar E
   MatchChar C
   MatchChar T
   Skip " \t"
   Match "=:"
   Skip " \t"
   GetNumber baudrate
   SkipOnce ",;"
   Skip " \t"
   GetNumber stop
   SkipOnce ",;"
   Skip " \t"
   GetNumber parity
   Skip " \t"
   Match "\r\n"
   Match "\r\n"


*/
